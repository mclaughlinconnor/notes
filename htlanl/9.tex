\section{Session Nine}\label{sec:session_nine}

\subsection{Mutability (Lists)}\label{sub:mutability}

\emph{Mutability} describes whether or not an object can be altered after it has been initialised.
Since we can do \mintinline{python}{items.append(element)}, the list \mintinline{python}{items} is mutable.
In Python, core types (like \mintinline{python}{int}s and \mintinline{python}{str}s) are immutable, that's why \mintinline{python}{"str" + "ing"} creates a new string \mintinline{python}{"string"}.

\subsubsection{Side-effects of Mutability}\label{ssub:side_effects_of_mutability}

\begin{minted}{python}
    items = [[0]] * 3
    new_items = items
    new_items[0][0] = 1
    print(items) -> "[[1], [1], [1]]"
    print(new_items) -> "[[1], [1], [1]]"
\end{minted}

\subsubsection{Copying Lists}\label{ssub:copying_lists}

\begin{center}
	\begin{minted}{python}
        items = [1, 2, 3]
        b = a[:]
        b.append(4)
        a == b -> False   
    \end{minted}
\end{center}

\subsubsection{Testing for Equality}\label{ssub:testing_for_equality}

\noindent
Assigning means both variables are equal:

\begin{center}
	\begin{minted}{python}
        a = [1]
        b = [1]
        a == b -> True
    \end{minted}
\end{center}

\noindent
Copying creates an identical list:

\begin{center}
	\begin{minted}{python}
        a = [1]
        b = a[:]
        a == b -> True
    \end{minted}
\end{center}

\noindent
Assigning just assigns a reference to the new variable, instead of making a new list:

\begin{center}
	\begin{minted}{python}
        a = [1]
        b = a
        a is b -> True
    \end{minted}
\end{center}

\noindent
Copying a list creates a brand new list so they don't have the same \mintinline{python}{id()}:

\begin{center}
	\begin{minted}{python}
        a = [1]
        b = a[:]
        a is b -> False
    \end{minted}
\end{center}

\noindent
Since assigning just assigns the reference, the original can be altered by changing the second one:

\begin{center}
	\begin{minted}{python}
        a = [1]
        b = a
        b.append(2)
        print(a) -> [1, 2]
    \end{minted}
\end{center}

\subsection{Mutability (Tuples)}\label{sub:mutability_tuples_}

Tuples are immutable meaning that once have been created, they cannot be changed.
Tuples use the same syntax as lists, except with \mintinline{python}{()} instead of \mintinline{python}{[]}. eg \mintinline{python}{items = (1, 2, 3, 4)}.
Tuples are good for debugging since they cannot be changed after initialisation.
It is possible to convert lists to tuples using the \mintinline{python}{tuple(items)} command and \mintinline{python}{list(items)} to go back again.

\begin{minted}{python}
    a = ("2", 3, [1, 2, 3])
    a[2] = [4, 5, 6] -> TypeError
    a[2][1] = 3 -> Works
\end{minted}

\subsection{Dictionaries}\label{sub:dictionaries}

Lists are indexed by integers, \mintinline{python}{dict}s are indexed with any immutable object.
Dictionaries (also called \emph{hash maps} or \emph{hash tables}) are used to associate data with other data.

Hash maps and dictionaries don't have any order (Python \mintinline{python}{dict}s actually do, but ignore this).
Dictionaries have keys and values where keys are used to index the data and the values are the data itself.

Dictionaries are very good for lookup tables and are able to be defined using the literal syntax and by instantiating: \mintinline{python}{items = {"one": 1, "two": 2}} or \mintinline{python}{items = dict("one"=1, "two"=2)}
They are used for lookup tables because searching through a list is very slow whereas dictionaries are almost instant.
Another good use for hash maps is for memoization - which is keeping track of precalculated values to avoid redoing expensive calculations.

A bad use for dictionaries is to reduce the number of parameters on a function.
In this case it is better to simplify the function.

\begin{note}
	Dictionaries cannot be searched and cannot have duplicate identifiers.
\end{note}

\subsubsection{Hashing}\label{ssub:hashing}

Internally, dictionaries use a unique string to identify each individual value.
Every key must be unique, hashable and immutable so they all have a constant \mintinline{python}{id()}.
If you were to try and assign to the same key twice, the first gets overwritten with the second value.

\subsubsection{Deletion}\label{ssub:deletion}

\begin{itemize}
	\item Use \mintinline{python}{del items["one"]} to delete the item with key ``one''.
	\item \mintinline{python}{item.pop()} will remove and return a random value from the dictionary.
	\item \mintinline{python}{item.popitem()} removes a random item and return a key, value pair.
\end{itemize}
