\section{Instructions Introduction}\label{sec:instructions_introduction}

\subsection{Key ideas for programmable machines}\label{sub:key_ideas_for_programmable_machines}

\begin{itemize}
    \item   A machine that can perform a fixed sequence of simple arithmetic operations
    \item Provide a way to change that sequence (punch cards, code)
    \item Make it possible to compare two numbers and decide what to do next (A Babbage's Analytical Engine -- the first turing-complete machine).
\end{itemize}

\subsection{The language of machines}\label{sub:the_language_of_machines}

There are many programming languages, but each machine has its own machine language.
Each programming language is translated in to machine language by software called a compiler.

\subsection{Machine Language}\label{sub:machine_language}

Examples:
\begin{itemize}
    \item x86
    \item ARM
    \item MIPS
    \item SPARC
\end{itemize}
All are different.

\subsection{Compiling}\label{sub:compiling}

Computers cannot directly execute high-level code.
We must translate them into assembly language (called compiling).
This is done by a compiler: it reads in a program in a language, then translates to assembler language.

There are some benefits of compilers:
\begin{itemize}
    \item Can run programs in many languages
    \item computers can make programming easier.
    \item Languages can be designed to fit well for different purposes.
\end{itemize}

Each high level languages construct, we translate to assembly following a standard pattern (these patterns are the learning outcome of this chapter).

\subsection{What is an instruction set?}\label{sub:what_is_an_instruction_set_}

The complete collect ion of instructions understood by a CPU.

\subsection{Instruction Representation}\label{sub:instruction_representation}

Each instruction is a bit pattern (machine code).
For ease of programming we use a symbolic representation (ADD, SUB, LOAD) -- these a are called mnemonics.
Operations can be like this: ADD A,B.

\subsection{Elements of an Instruction}\label{sub:elements_of_an_instruction}

\begin{itemize}
    \item Must have an operation code (what to do)
    \item Source operand reference (what to do it to)
    \item Result operand reference (where the answer goes)
    \item Next instruction reference (what to do next, blank for next instruction)
\end{itemize}

\subsection{What are the operands}\label{sub:what_are_the_operands}

\begin{itemize}
    \item Main memory (or virtual memory)
    \item Processor register (if there's only one, use ACCUMULATOR)
    \item Immediate (use a constant)
    \item IO device
\end{itemize}

\subsection{Number of operands}\label{sub:number_of_operands}

Varies depending on type of instruction and computer architecture (CISC, RISC)

\subsection{Format}\label{sub:format}

For a \(16\) bit instruction maybe:
\begin{itemize}
    \item \(4\) bit opcode
    \item \(6\) bit operand reference
    \item \(6\) bit operand reference
\end{itemize}

\subsection{Instruction Types}\label{sub:instruction_types}

Whatever is written by you must be expressible in machine language:
\begin{itemize}
    \item Data processing
    \item Data storage (main memory)
    \item Data movement (IO)
    \item Flow control
\end{itemize}

\section{Basic Assembly Instructions}\label{sec:basic_assembly_instructions}

\subsection{Comparison}\label{sub:comparison}

Assembly:
\begin{itemize}
    \item Program is text and easier to read.
    \item Don't need to remember codes
    \item Memory addresses are easier to handle (ie.\ not a massive address).
\end{itemize}
%
Machine language:
\begin{itemize}
    \item Binary numbers represented as hex
    \item It is possible for a digital circuit to execute
    \item No names for instructions (everything is a number)
\end{itemize}

\subsection{Instructions}\label{sub:instructions}

A machine language provides instructions.
Are basically statements:
\begin{itemize}
    \item Can be complex: \(x:=2*(a+b/c)\)
    \item Can be simple: \(R_2:=R_1 + R_3\)
    \item Each instruction performs one action
\end{itemize}

\subsection{Types of operation}\label{sub:types_of_operation}

\begin{itemize}
    \item Data storage (main memory)
    \item Data processing
          \begin{itemize}
              \item Arithmetic
              \item Logical
              \item Conversion
          \end{itemize}
    \item Data movement (IO)
    \item Program flow control
          \begin{itemize}
              \item System control
              \item Transfer of control
          \end{itemize}
\end{itemize}

\subsection{Data storage to main memory}\label{sub:data_storage_to_main_memory}

Transfer data between processor and main memory.
Must specify source, destination and amount of data.
May be different instructions for different movements (to or from, etc.).

\subsection{Data processing}\label{sub:data_processing}

\begin{itemize}
    \item Add, subtract, multiply, divide
    \item Signed integer
    \item Increment, decrement, negate
    \item Bitwise operations
    \item AND, OR, NOT
\end{itemize}
%
We also can do shift and rotate operations which shift along one bit either by wrapping around (rotate) or by pushing a \(0\).
With arithmetical shift, etc. the MSB is signed, for logical it isn't.

\subsection{Data Movement}\label{sub:data_movement}

Common to use memory load/store instructions specifically to move data to and from memory mapped IO devices.

\subsection{Program Control}\label{sub:program_control}

For system control:
\begin{itemize}
    \item Privileged instructions
    \item CPU needs to be in a specific state
    \item For operating system use
\end{itemize}
%
Transfer of control (flow control)
\begin{itemize}
    \item Branches (conditional and unconditional branches)
    \item Skipping
    \item Subroutine call (interrupt call)
\end{itemize}
