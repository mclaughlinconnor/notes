\section{Web Application Frameworks}\label{sec:web_application_frameworks}

\subsection{Why use a framework?}\label{sub:why_use_a_framework_}

Once you have developed several web applications, it will be very clear that you are repeatedly implementing the same few pieces of functionality.
Using a framework will give you well tested and robust implementations for database handling, templating, and for having good separation of concerns.

\subsubsection{Pre-fabricated Wheels}\label{ssub:pre_fabricated_wheels}

A web application framework will usually provide pre-built classes for:
\begin{itemize}
    \item Authentication
    \item Database abstraction (or ORM)
    \item Template system
    \item An AJAX sub-framework
    \item Session management
    \item An architecture based on the model-view-controller system
\end{itemize}

\subsection{Model View Controller}\label{sub:model_view_controller}

The MVC pattern separates data and business logic from presentation.
In web applications:
\begin{itemize}
    \item The view is often HTML generated by the application
    \item The controller receives GET or POST requests and processes data.
    \item The model then gets the data needed to carry out the task.
\end{itemize}

\subsubsection{What is a design pattern?}\label{ssub:what_is_a_design_pattern_}

A design pattern is a tool to communicate ideas, solutions and knowledge about a common design problem which can be expressed hierarchically as a three part rule between a context, a problem, and a solution where each stage in the hierarchy has its own level of granularity.
A software design pattern can be paired with a user interface design pattern to help developers create effective and usable user interfaces.

\begin{note}
    Although there are standard ways to implement a design pattern, there can be more than one for each pattern; it is up to the developer to choose which to use.
\end{note}

\subsubsection{MVS and GUIs}\label{ssub:mvs_and_guis}

The MVC design pattern was originally invented in the \(1970\)s by Xerox where it was used to map mouse and keyboard inputs to actions.
The actions Xerox used were sent to either the model -- or the application state, or database -- or update the display.

\begin{description}
    \item[Controller] Interprets user input
    \item[Model] Handles data for the application
    \item[View] Manages and represents data
\end{description}

\subsubsection{Model}\label{ssub:model}

Contains code that operates on the application data.
All CRUD operations must go through this layer:
\begin{itemize}
    \item Retrieve or query the state
    \item Create new data
    \item Update the current state
    \item Delete
\end{itemize}
A model is a class which represents the application data and domain logic.
When data in the model is changed, it will trigger an update on the views, but views can query the model at any time.
A controller can also access the model, where some of the application data functionality will be kept.

\subsubsection{View}\label{ssub:view}

The view is a visual representation of a model that defines how the pages should look and how the user can submit actions to be executed with the controller.
A view is attached to a model so when the model changes, the view must update too using one of two methods:
\begin{description}
    \item[Push model] View registers itself with the model for change notifications
    \item[Pull model] the view calls the model when it needs the most up to date data.
\end{description}
The view is responsible for forwarding user requests to the controller.

\subsubsection{Controller}\label{ssub:controller}

The controller defines the application behaviour by controlling the flow of the program by receiving and processing user commands on the model which get output to the view -- which links the user to the application system.

By separating the model from the controllers and views, we can show different data or layouts to many different people for many different people.

\subsubsection{MVC advantages}\label{ssub:mvc_advantages}

\begin{itemize}
    \item Enable independent development and testing (model, view, controllers can be different teams)
    \item Easier to maintain
    \item Provides reusable view s and model
    \item Sync views and multiple simultaneous views
    \item Enforce logical separation of concerns
\end{itemize}

\subsubsection{Disadvantages}\label{ssub:disadvantages}

\begin{itemize}
    \item More initial overhead (\(3\) classes vs \(1\)) especially for simple applications
    \item Debugging can be a problem (is it a model problem, view problem, etc.)
    \item Required the developers to understand patterns.
\end{itemize}

\section{Frameworks}\label{sec:frameworks}

As with frameworks in the real world (eg.\ a building frame or vehicle chassis), software frameworks have designs and partial implementations for a specific domain of applications.
Frameworks allow developers to create applications faster by giving sane default functionality to be extended and overridden.

\subsection{Framework definitions}\label{sub:framework_definitions}

\begin{itemize}
    \item A set of abstract classes for a family of problems.
    \item A frameworks is the reusable design of a system of abstract classes and how those interact.
    \item A framework is a reusable software architecture made of both design and code.
\end{itemize}

\subsection{The Characteristics of a Framework}\label{sub:characteristics}

\begin{itemize}
    \item Inversion of control: framework is responsible for the application control flow.
    \item Sane and useful default behaviour is provided
    \item Extensibility means plugins can be used for specific purposes
    \item Non-modifiable framework code where key components cannot be altered.
\end{itemize}

\subsection{Why should you use a framework?}\label{sub:why_frameworks}

\begin{itemize}
    \item All applications have common requirements: security, password recovery, database management, session management which a framework can include and provide high levels of support for.
    \item Frameworks encapsulate the thousands of hours of experience from each of the authors that is improved on each iteration.
    \item They can often support very large amounts of traffic right out of the box.
    \item Allows for a rapid development for rapid release cycle that is common with web development.
    \item Reduce the development effort of programming in several programming languages (HTML, CSS, SQL, Javascript).
    \item Manage the complexity of large web applications like user authentication, session management, etc.
    \item Reduce boilerplate code (CRUD, session management).
    \item A framework allows you to focus only on what makes the application unique.
    \item Increased security (until an exploit is found in the framework and your application is now vulnerable).
    \item Frameworks are extensively tested so are very robust.
\end{itemize}

\subsection{Why should you not use a framework?}\label{sub:why_should_you_not_use_a_framework_}

\begin{itemize}
    \item Inversion of control gives away some of the control a developer usually has
    \item Code outside of what is supported can be \emph{very} difficult
    \item Frameworks can introduce extra code bloat
    \item Levels of abstraction can introduce performance penalties
    \item Frameworks can have a very steep learning curve
    \item Can be poorly documented
    \item A bug or security problem can seriously compromise the application
\end{itemize}

\subsection{Frameworks vs Libraries}\label{sub:frameworks_vs_libraries}

Framework is about reusing behaviours by controlling how abstract classes and components interact with each other.
A framework will call your own application code, whereas a library just adds additional reusable functionality to your existing application.

