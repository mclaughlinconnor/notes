\section{Faking}\label{sec:faking}

\subsection{Doubling}\label{sub:doubling}

\begin{itemize}
	\item Stub: A function or class that returns hard coded values.
	\item Mock: a framework used to set dummy values to be returned from mocked classes at runtime.
	\item Faking: A stub that has some logic and is a simplified version of a real external application that creates fake responses (an in memory database or just replaying user inputs).
\end{itemize}

\subsection{Why fake?}\label{sub:why_fake_}

\begin{itemize}
	\item It can be slow to access external data
	\item It can be difficult to access real world data so this is a good way to get fake data
\end{itemize}

\subsection{Examples}\label{sub:examples}

\subsubsection{Faking a database}\label{ssub:faking_a_database}

A normal database is persistent and is often slow to call and costly to have in testing environments.
An in memory database is not persistent an is not visible externally, but still allows data to be inserted, deleted, queried and should closely match a real database (maybe just an old version).
Sqlite and H2 are commonly used databases used for this.

\subsubsection{Faking a webpage}\label{ssub:faking_a_webpage}

You would download a webpage and host it locally (there should be a variable in your code to switch easilty between live and fake webpages).
Can be used for screen scraping programs.
You should load the page only once to save on memory.

\subsubsection{Faking an API}\label{ssub:faking_an_api}

If you fake an API, you are able to run external systems.
You could simply switch the library you are calling with a basic version that accepts requests and turns them into simple responses.

\subsubsection{Faking a webservice}\label{ssub:faking_a_webservice}

An external application might be expensive, this avoids them.
You could use URL matching, query matching, etc.\ to decide which response to send.
You might make a JSON response.
You could record what the real webservice responds to certain requests, then just replay them on your fake webservice.

\subsubsection{Faking user input}\label{ssub:faking_user_input}

Create an adapter for getting the user input.
Record and replay user input and compare your the output of your program.

\subsection{Questions to ask}\label{sub:questions_to_ask}

\begin{itemize}
	\item What are the input and output operations?
	\item What requests are being made?
	\item What responses are received?
	\item What requests are received?
	\item What are the agreed upon responses?
	\item Are there different types of requests and responses?
	\item Does data or information make a difference on the request or response being made?
\end{itemize}
